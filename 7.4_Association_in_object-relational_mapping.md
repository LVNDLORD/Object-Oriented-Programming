# 7.4. Association in object-relational mapping

In the previous submodule, we learned how to map a class to a table in the database. In this submodule, we will learn how to map associations between classes to tables in the database.

This time we let Hibernate generate the database tables for us. We will use the same example as in the previous submodule, but this time we will add a new class, `Department`, and an association between `Employee` and `Department`.


## 7.4.1. Association, navigability, and cardinality

Association means that two classes are related to each other. In the example, `Employee` and `Department` are associated with each other.

Navigability means that we can navigate from one class to another class. For example, if an `Employee` object knows which `Department` it belongs to, we can navigate from `Employee` to `Department`. If a `Department` object knows which `Employee`s belong to it, we can navigate from `Department` to `Employee`. An association can be unidirectional or bidirectional.

Cardinality means how many objects of one class can be associated with an object of another class. For example, an `Employee` can belong to only one `Department`, but a `Department` can have many `Employee`s. When annotating associations, it is vital to specify the cardinality correctly. If we specify the cardinality incorrectly, Hibernate will not be able to generate the database tables correctly.

Let's consider the following example shown in the UML class diagram:

![Associated classes](images/associated_classes.png)

In the image, the arrowhead displays the navigability of the association. The arrowhead points from `Employee` to `Department`, which means that we can navigate from `Employee` to `Department`, or that the `Employee`object knows which `Department` it belongs to. Other solutions are also possible at the Java level: for instance we could have a `Department` object that knows which `Employee`s belong to it. In this case, the arrowhead would point from `Department` to `Employee`. Or, we could make the association bi-directional, so that both `Employee` and `Department` know about each other. In this case, the arrowhead would point from both `Employee` and `Department` to each other. Irrespective of how we choose the navigability of the association, Hibernate will generate the database tables correctly, provided that we specify the cardinality correctly.

The symbols `*` and `1` in the diagram indicate the cardinality. That is, one department per employee, and many employees per department. 

## 7.4.2. Preparing the database

As we don't want to damage our existing `company` database, we create a new database for this example. Let's call the database `company2`.

First, we create the database in the SQL editor (such as HeidiSQL) or command prompt:
    
```sql
CREATE DATABASE company2;
```

Then we give our existing user account the privileges to perform CRUD operations on the new database:

```sql
GRANT SELECT,INSERT,UPDATE,DELETE ON company2.* TO 'appuser'@'localhost';
```

As we let Hibernate create (and drop) tables this time, we also need to grant the privileges for that:
```sql
GRANT CREATE, DROP ON company2.* TO 'appuser'@'localhost';
```

Now we are ready to start writing the application. We can copy the previous example of submodule 7.3. and modify it to suit our needs.


## 7.4.3. Persisting the data

The first thing to do is to tell Hibernate that we want the database tables to be created automatically. We do this by modifying the 
property with the name `jakarta.persistence.schema-generation.database.action` in the `hibernate.cfg.xml` file. We change the value from `none` to 'drop-and-create`:

```xml
<property name="jakarta.persistence.schema-generation.database.action" value="drop-and-create"/>
```

Then we write the DAO classes for our application. This time, we add a new instance variable into the `Employee` class that contains a reference
to the `Department` object that the employee belongs to:

```java
package entity;

import jakarta.persistence.*;

@Entity
public class Employee {

    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private int id;
    private String firstName;
    private String lastName;
    private String email;
    private double salary;
    @ManyToOne
    private Department department;

    public Employee(String firstName, String lastName, String email, double salary, Department department) {
        super();
        this.firstName = firstName;
        this.lastName = lastName;
        this.email = email;
        this.salary = salary;
        this.department = department;
    }

    public Employee() {
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }
}

```

The reference to the Department is annotated with the `@ManyToOne` annotation. This annotation tells Hibernate that the association is many-to-one, that is, many employees can belong to one department. This time, as we let Hibernate generate the database tables, we don't need to specify the names of the columns. Hibernate will automatically use the instance variable names as the column names. Also, the table name will be taken directly from the class name.

Next, we add the new class, `Department` to the `entity`package that now contains two classes. The `Department` class looks like this:

```java
package entity;

import jakarta.persistence.*;

@Entity
public class Department {

    @Id
    private int id;
    private String name;

    public Department(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public Department() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }
}

```

This class contains only the mandatory annotations. The `@Id` annotation tells Hibernate that the `id` instance variable is the primary key of the table. The `@Entity` annotation tells Hibernate that this class is an entity class.

As the Department objects do not know anything about the Employee objects, we don't need to add any annotations about the association to the `Department` class.

We also write a new DAO class, `DepartmentDAO` that contains the methods for saving and retrieving `Department` objects:

```java
package dao;

import entity.*;
import jakarta.persistence.EntityManager;

public class DepartmentDao {

    public void persist(Department dept) {
        EntityManager em = datasource.MariaDbJpaConnection.getInstance();
        em.getTransaction().begin();
        em.persist(dept);
        em.getTransaction().commit();
    }

    public Department find(int id) {
        EntityManager em = datasource.MariaDbJpaConnection.getInstance();
        Department dept = em.find(Department.class, id);
        return dept;
    }
}
```

For simplicity, we omitted the other methods from the DAO classes, such as the ones for updating and deleting objects.

Finally, the updated `CompanyApp` class in the `application` package inserts a few employees into the database:

```java
package application;

import entity.*;
import dao.*;
public class CompanyApp {
    public static void main(String[] args) {

        EmployeeDao empdao = new EmployeeDao();
        DepartmentDao deptdao = new DepartmentDao();

        Department d1 = new Department(1, "Sales");
        Department d2 = new Department(2, "Marketing");

        deptdao.persist(d1);
        deptdao.persist(d2);

        empdao.persist(new Employee("Viivi", "Puro", "viivip@mymail.fi", 7300.00, d2));
        empdao.persist(new Employee("Tero", "Koski", "tero.koski@mymail.fi", 3750.00, d1));
        empdao.persist(new Employee("Ahmed", "Bakir", "ahmed.bakir@mymail.fi", 4800.00, d1));

    }
}
```

As we run the application, we get the following console output:
```
Hibernate: alter table if exists Employee drop foreign key if exists FK14tijxqry9ml17nk86sqfp561
Hibernate: drop table if exists Department
Hibernate: drop table if exists Employee
Hibernate: create table Department (id integer not null, name varchar(255), primary key (id)) engine=InnoDB
Hibernate: create table Employee (id integer not null auto_increment, email varchar(255), firstName varchar(255), lastName varchar(255), salary float(53) not null, department_id integer, primary key (id)) engine=InnoDB
Hibernate: alter table if exists Employee add constraint FK14tijxqry9ml17nk86sqfp561 foreign key (department_id) references Department (id)
Hibernate: insert into Department (name, id) values (?, ?)
Hibernate: insert into Department (name, id) values (?, ?)
Hibernate: insert into Employee (department_id, email, firstName, lastName, salary) values (?, ?, ?, ?, ?)
Hibernate: insert into Employee (department_id, email, firstName, lastName, salary) values (?, ?, ?, ?, ?)
Hibernate: insert into Employee (department_id, email, firstName, lastName, salary) values (?, ?, ?, ?, ?)
```

We see that a lot has happened behind the scenes:

1. Hibernate has dropped the old tables from the database (if they existed).
2. Hibernate has created the tables for the `Employee` and `Department` classes. The foreign key field `department_id` has been added to the `Employee` table.
3. Hibernate has inserted the data into the tables.

The content of the database tables after the execution looks as follows:

```
+----+-----------+
| id | name      |
+----+-----------+
|  1 | Sales     |
|  2 | Marketing |
+----+-----------+

+----+-----------------------+-----------+----------+--------+---------------+
| id | email                 | firstName | lastName | salary | department_id |
+----+-----------------------+-----------+----------+--------+---------------+
|  1 | viivip@mymail.fi      | Viivi     | Puro     |   7300 |             2 |
|  2 | tero.koski@mymail.fi  | Tero      | Koski    |   3750 |             1 |
|  3 | ahmed.bakir@mymail.fi | Ahmed     | Bakir    |   4800 |             1 |
+----+-----------------------+-----------+----------+--------+---------------+
```


## 7.4.3. Retrieving objects

## 7.4.3. Other types of associations

