# Static variables and methods

## Static variable

In Java, a static variable is a variable that belongs to the class itself rather than to any particular instance of the class. It is also known as a class variable. Unlike instance variables, which are unique to each instance of a class, static variables have the same value across all instances of the class.
![](images/ClassVariable.png)

Here are some key characteristics of static variables:

1. Shared value: When you declare a variable as static, it is shared among all instances of the class. Any changes made to the static variable will be reflected in all instances of the class.

2. Memory allocation: Static variables are allocated memory in a separate area called the "static memory" or "class area." This memory is allocated when the class is loaded by the Java Virtual Machine (JVM) and exists until the program terminates.

3. Access and visibility: Static variables can be accessed directly using the class name, without creating an instance of the class. They are visible to all instances of the class and can also be accessed from other classes (depending on their access modifiers).

4. Initialization: Static variables are initialized only once, when the class is loaded by the JVM. They can be assigned a value directly at the point of declaration or within a static initializer block.

Here's an example that demonstrates the usage of a static variable in Java:

```java
public class Counter {
    private static int count = 0; // static variable

    public Counter() {
        count++; // Increment count each time a new instance is created
    }

    public static void main(String[] args) {
        Counter c1 = new Counter();
        System.out.println("Count: " + Counter.count); // Accessing static variable using class name

        Counter c2 = new Counter();
        System.out.println("Count: " + Counter.count);
    }
}
```

In the above example, the `count` variable is declared as static. Each time a new `Counter` instance is created, the `count` variable is incremented. As `count` is a static variable, its value is shared among all instances of the `Counter` class. The output of the program will be:

```
Count: 1
Count: 2
```

Note that static variables should be used with caution, as they can introduce shared state and potential synchronization issues in multithreaded environments.

## Static method

In Java, a static method is a method that belongs to the class itself rather than to any particular instance of the class. It is also known as a class method. Static methods can be called directly using the class name, without the need to create an instance of the class.

Here are some key characteristics of static methods:

1. No access to instance variables: Static methods do not have access to instance variables or methods directly. They can only access other static members (variables or methods) of the class.

2. No use of "this" keyword: Since static methods are not associated with any instance, they cannot use the "this" keyword to refer to the current object.

3. Memory allocation: Static methods are stored in the same class area as static variables, known as the "static memory" or "class area." They are loaded into memory when the class is loaded by the JVM.

4. Access and visibility: Static methods can be accessed directly using the class name, without creating an instance of the class. They are visible to all instances of the class and can also be accessed from other classes (depending on their access modifiers).

5. Cannot be overridden: Static methods cannot be overridden by subclasses. If a subclass defines a static method with the same signature as a static method in its superclass, it is simply hiding the superclass method rather than overriding it.

Here's an example that demonstrates the usage of a static method in Java:

```java
public class MathUtils {
    public static int add(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        int result = MathUtils.add(5, 3); // Calling static method directly using class name
        System.out.println("Result: " + result);
    }
}
```

In the above example, the `add` method is declared as static. It takes two integers as parameters and returns their sum. The `add` method can be called directly using the class name without creating an instance of the `MathUtils` class. The output of the program will be:

```
Result: 8
```

Static methods are commonly used for utility methods or helper functions that don't require any specific instance state. They can be called directly from anywhere in the program, making them convenient for performing operations that are not dependent on object state.

# Packages

## Directories in file systems
You store your content in files. When you have only few files, you will find your files easily and the probability of naming conflicts (two files with a same name) is low. But when the number of files will increase, then it is more difficult to find a particular file. We need a solution for handling larger number of files, and it is a [_directory_](https://en.wikipedia.org/wiki/Directory_(computing)).

Directories (also known as folders) in file systems serve several purposes and provide organizational and structural benefits. Here are some reasons why directories are used in file systems:

1. Hierarchical organization: Directories provide a hierarchical structure for organizing files and other directories. This structure allows for logical grouping and categorization of related files and helps users navigate and locate specific files easily. It provides a way to organize and manage files in a structured manner, similar to how physical folders are used to organize documents.

2. File management: Directories facilitate efficient file management. They allow users to create, rename, move, and delete files. By organizing files into directories, users can keep related files together, making it easier to find and work with them.

3. Namespace management: Directories help manage the namespace or the set of unique names used to identify files. They provide a way to differentiate files with the same name by placing them in different directories. This prevents naming conflicts and allows users to have files with identical names in different locations.

4. Access control and permissions: Directories can have access control mechanisms and permissions associated with them. This means that you can specify who can access, modify, or delete files within a particular directory. Access control helps maintain security and privacy by restricting unauthorized access to files.

5. File organization and separation: Directories allow for logical separation and organization of files based on their content, purpose, or ownership. For example, you may have directories for documents, images, videos, programs, or specific projects. This separation helps in maintaining a structured file system, improves searchability, and enhances file organization.

6. Navigation and file path addressing: Directories enable navigation within the file system using relative and absolute file paths. Users can navigate through directories to locate specific files or move between different locations in the file system. Directories help in identifying the path to a file, specifying its location within the file system.

Overall, directories in file systems provide a systematic way to organize, manage, and access files. They improve file management, prevent naming conflicts, enable access control, and help users navigate the file system effectively.

## Packages and directories have similarities

When we have a large application, it contains large amount of different source code files (for the class definitions, remember that in Java, classes are defined on their separate files). We need similar kind of tool than directory to manage our class files, and that tool is called as _package_.

Packages are used to organize classes and interfaces into a hierarchical structure, similar to directories in a file system. A package provides a way to group related classes and helps in avoiding naming conflicts between classes with the same name in different packages.

Here are some key points about packages in Java:

1. Package declaration: At the beginning of a Java source file, you can declare the package to which the class belongs using the `package` keyword. The package declaration must be the first line of code in the file (except for comments and white space). For example:

   ```java
   package com.example.myapp;
   ```

   The package declaration for a class named `MyClass` in the package `com.example.myapp` would look like:

   ```java
   package com.example.myapp;

   public class MyClass {
       // Class code goes here
   }
   ```

2. Package naming convention: Package names are typically written in all lowercase letters to follow the Java naming conventions. Packages are usually named in a reverse domain name format to ensure uniqueness. For example, if a company's domain name is `example.com`, the corresponding package name could be `com.example`.

3. Package structure: Packages can be nested to create a hierarchical structure. For example, the package `com.example.myapp` can have sub-packages like `com.example.myapp.utils` and `com.example.myapp.models`. This helps in organizing related classes and provides a clear structure for larger projects.

4. Access control: Classes and interfaces in Java have access control modifiers like `public`, `protected`, `private`, and default (no modifier). The access modifiers determine whether classes/interfaces in a package are accessible to other classes and packages. By default, classes/interfaces without an access modifier (default access) are accessible within the same package.

5. Importing classes: To use a class from a different package, you need to import it using the `import` statement. This allows you to refer to the class by its simple name rather than its fully qualified name (package name + class name). For example:

   ```java
   import com.example.myapp.utils.UtilityClass;

   public class AnotherClass {
       public static void main(String[] args) {
           UtilityClass.doSomething(); // Using the imported class
       }
   }
   ```

   If you don't import a class explicitly, you need to refer to it using its fully qualified name:

   ```java
   public class AnotherClass {
       public static void main(String[] args) {
           com.example.myapp.utils.UtilityClass.doSomething(); // Using the fully qualified name
       }
   }
   ```

Packages are an essential part of Java's modular structure, enabling code organization, encapsulation, and reusability. They promote good software engineering practices by providing a structured way to manage classes and reduce naming conflicts.

<!-- https://java-programming.mooc.fi/part-11 -->

# Modifiers

Modifiers in Java are keywords that are used to control the accessibility, behavior, and scope of classes, methods, variables, and other elements in a Java program. They define the level of access and visibility to other classes and components within the program. Java provides a variety of modifiers that can be applied to different elements. Here are some commonly used modifiers in Java:

1. Access Modifiers:
    - `public`: Allows unrestricted access from anywhere.
    - `protected`: Provides access within the same package and subclasses.
    - `private`: Restricts access to within the same class.

2. Non-Access Modifiers:
    - `final`: Indicates that a variable, method, or class cannot be modified or extended.
    - `static`: Specifies that a variable or method belongs to the class itself rather than an instance.
    - `abstract`: Used in classes or methods to indicate that they are incomplete and must be extended or implemented by a subclass.
    - `synchronized`: Ensures that only one thread can access a synchronized method or block at a time.
    - `volatile`: Indicates that a variable's value may be modified by different threads and should not be cached.

3. Class Modifiers:
    - `public`: Allows the class to be accessed from anywhere.
    - `abstract`: Specifies that the class cannot be instantiated and must be extended by a subclass.
    - `final`: Indicates that the class cannot be extended.
    - `strictfp`: Ensures strict adherence to floating-point calculations.

4. Method Modifiers:
    - `public`, `protected`, `private`: Determines the visibility and access level of the method.
    - `static`: Specifies that the method belongs to the class and can be invoked without creating an instance of the class.
    - `abstract`: Indicates that the method is declared but does not provide an implementation.
    - `final`: Prevents the method from being overridden in a subclass.
    - `synchronized`: Ensures that only one thread can execute the method at a time.
    - `native`: Specifies that the method is implemented in a language other than Java.

5. Variable Modifiers:
    - `public`, `protected`, `private`: Determines the visibility and access level of the variable.
    - `static`: Indicates that the variable belongs to the class rather than an instance.
    - `final`: Makes the variable a constant that cannot be modified.
    - `volatile`: Indicates that the variable's value may be modified by different threads.
    - `transient`: Excludes the variable from being serialized.
    - `synchronized`: Ensures that only one thread can access the variable at a time.

Modifiers provide control over encapsulation, inheritance, polymorphism, and other aspects of Java programming. They allow for proper access control, define behavior, and enforce design principles such as immutability and thread safety. The selection and combination of modifiers depend on the specific requirements and design considerations of the program.
