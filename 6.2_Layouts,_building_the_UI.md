# 6.2. Layouts, building the UI

In the previous submodule, we learnt the basics of building a graphical user interface. In this submodule, we will learn how to build a more complex UI, using layouts.

In JavaFX, layouts are containers that can be used to group UI elements together. They are a way to organize the UI elements in a specific way. For example, we can use layouts to create a grid of buttons, or to stack buttons on top of each other.

In the examples of the previous submodule, we used one layout: the FlowPane. The FlowPane is a simple layout that stacks the UI elements horizontally or vertically. It is not very useful for building complex UIs, but it is a good layout to start with.

In this submodule, we will learn about more layouts used in JavaFX: the BorderPane, the GridPane, the HBox and the VBox. We will also learn how to use CSS to style our UI elements.

For each layout, a simple example with Button elements is shown. The examples are not very useful per se, but they are a good way to learn how the layouts work.

## 6.2.1. The BorderPane

The BorderPane is a layout that divides the window into five regions: top, bottom, left, right and center. Each region can contain only one UI element. The following image shows a BorderPane with a button in each region:

![borderpane](images/borderpane.png)

The following code shows how to create a BorderPane and add a button to each region:

```java
public class BorderPaneExample extends Application {

    @Override
    public void start(Stage window) {
        BorderPane layout = new BorderPane();

        Button topButton = new Button("NORTH");
        Button rightButton = new Button("EAST");
        Button bottomButton = new Button("SOUTH");
        Button leftButton = new Button("WEST");
        Button centerButton = new Button("CENTER");

        layout.setTop(topButton);
        layout.setRight(rightButton);
        layout.setBottom(bottomButton);
        layout.setLeft(leftButton);
        layout.setCenter(centerButton);

        Scene view = new Scene(layout);

        window.setScene(view);
        window.show();
    }

    public static void main(String[] args) {
        launch(BorderPaneExample.class);
    }

}
```

Note that the content located in the TOP and BOTTOM regions is not centered by default. If we would like to center the content in these regions, we can add the following lines to the code:

```java
layout.setAlignment(topButton, Pos.CENTER);
layout.setAlignment(bottomButton, Pos.CENTER);
```

In real applications, BorderPane provides a good layout for the main window of the application. The main menu of the application can be placed in the top region, and the main content of the application can be placed in the center region.

## 6.2.2. The GridPane

The GridPane is a layout that divides the window into a grid. The grid can have any number of rows and columns. Each cell of the grid can contain only one UI element. The following image shows a GridPane with a button in each cell:

![gridpane](images/gridpane.png)

The code that creates the GridPane and adds the buttons to it is shown below:

```java
public class LayoutDemo extends Application {

    @Override
    public void start(Stage stage) {
        GridPane layout = new GridPane();

        Button button1 = new Button("TOP LEFT");
        Button button2 = new Button("TOP RIGHT");
        Button button3 = new Button("BOTTOM LEFT");
        Button button4 = new Button("BOTTOM RIGHT");
        Button button5 = new Button("MIDDLE (with long text)");

        layout.add(button1, 0, 0);
        layout.add(button2, 1, 0);
        layout.add(button3, 0, 1);
        layout.add(button4, 1, 1);
        layout.add(button5, 0, 2, 2, 1);

        Scene view = new Scene(layout);

        stage.setScene(view);
        stage.show();
    }
}
```

The code adds the buttons to the GridPane by using the add method. The first parameter of the add method is the UI element to be added. The second and third parameters are the coordinates of the cell where the UI element is added. The coordinates start from the upper left corner of the grid, and the first column and row have index 0. The fourth and fifth parameters are the number of columns and rows that the UI element will span.

In the example, the last button is placed in the middle of the grid. It spans two columns and one row.

The GridPane is a good layout for building UIs that contain a grid of UI elements. An example of a natural layout for the GridPane is a chessboard, or the keyboard of a calculator.

## 6.2.3. The HBox and VBox

The HBox and VBox layouts are used to stack UI elements horizontally or vertically. The HBox stacks the UI elements horizontally, and the VBox stacks the UI elements vertically. The following image shows an HBox with a button in each cell:

![hbox](images/hbox.png)

The following code shows how to create an HBox and add buttons to it:

```java
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.*;
import javafx.stage.Stage;

public class LayoutDemo extends Application {

    public void start(Stage stage) {
        HBox layout = new HBox();

        Button[] buttons = new Button[12];

        for (int i = 0; i < 12; i++) {
            buttons[i] = new Button("" + (i + 1));
            layout.getChildren().add(buttons[i]);
        }

        Scene view = new Scene(layout);

        stage.setScene(view);
        stage.show();
    }
}

```

Note that the twelve buttons are placed in a single row. If the window is resized, the buttons will not wrap to the next row. When the window width becomes smaller than the width of the buttons, the buttons will be clipped.

The Vbox container behaves in the similar fashion. The difference is that the UI elements are stacked vertically. The following image shows a VBox with a button in each cell:

![vbox](images/vbox.png)

In the code, just change the `HBox`  to `VBox`, and the buttons will be stacked vertically. Analogously to the HBox, the buttons will not wrap to the next column when the window is resized. If the window height becomes smaller than that of the buttons, the buttons, again, will be clipped.


## 6.2.4. StackPane

The purpose of the StackPane is to stack UI elements on top of each other. This is useful if we want to place UI elements on top of a background image, or construct a component that consists of several layers, some of which may be transparent. The following image shows a StackPane with two stacked components:

![stackpane](images/stackpane.png)

The component in the bottom layer is a button, and the component in the top layer is a label. The label is transparent, and the button is visible through it.

The following code shows how to create a StackPane and add UI elements to it:

```java
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.*;
import javafx.stage.Stage;
import javafx.scene.control.Label;

public class LayoutDemo extends Application {

    public void start(Stage stage) {
        StackPane layout = new StackPane();

        Button button1 = new Button("[           ]");
        Label label = new Label("Hello!");

        label.setOpacity(0.5);

        layout.getChildren().add(button1);
        layout.getChildren().add(label);

        Scene view = new Scene(layout);

        stage.setScene(view);
        stage.show();
    }
}
```

## 6.2.5. AnchorPane

The AnchorPane is a layout that allows us to anchor UI elements to the top, bottom, left side, or right side of the window. Anchoring means that the distance between the UI element and the edge of the window is fixed.

The following image shows an AnchorPane with a button in each corner:

![anchorpane](images/anchorpane.png)

The following code shows how to create an AnchorPane and add UI elements to it:

```java
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.*;
import javafx.stage.Stage;
import javafx.scene.control.Label;

public class LayoutDemo extends Application {

    public void start(Stage stage) {
        AnchorPane layout = new AnchorPane();

        Button button1 = new Button("TOP LEFT");
        Button button2 = new Button("TOP RIGHT");
        Button button3 = new Button("BOTTOM LEFT");
        Button button4 = new Button("BOTTOM RIGHT");

        layout.getChildren().add(button1);
        layout.getChildren().add(button2);
        layout.getChildren().add(button3);
        layout.getChildren().add(button4);

        AnchorPane.setTopAnchor(button1, 10.0);
        AnchorPane.setLeftAnchor(button1, 10.0);

        AnchorPane.setTopAnchor(button2, 10.0);
        AnchorPane.setRightAnchor(button2, 10.0);

        AnchorPane.setBottomAnchor(button3, 10.0);
        AnchorPane.setLeftAnchor(button3, 10.0);

        AnchorPane.setBottomAnchor(button4, 10.0);
        AnchorPane.setRightAnchor(button4, 10.0);

        Scene view = new Scene(layout);

        stage.setScene(view);
        stage.show();
    }
}
```

In the example, each of the four buttons is anchored to a corner of the window. This is done by setting two anchors for each button. For example, the top left button is anchored to the top and left sides of the window. The distance to each side is 10 pixels.

Try resizing the window. You see that the buttons stay in the same place, as they are anchored to the respective locations.


## 6.2.6. FlowPane and TilePane

In the earlier submodule, we used the FlowPane to stack UI elements horizontally or vertically. You probably remember that the FlowPane arranges the UI elements in the order they are added to the layout. If the UI elements do not fit in the window, the FlowPane wraps the UI elements to the next row or column.

The TilePane is quite similar to the FlowPane. The difference is that the TilePane arranges the UI elements in a grid. The UI elements are placed in the grid in the order they are added to the layout. If the UI elements do not fit in the window, the TilePane wraps the UI elements to the next row or column. The following image shows a TilePane with a button in each cell. In the image, you see how resizing the window affects the layout:

![tilepane](images/tilepane.png)

In the following code, we create an array of 12 buttons and add them to a TilePane:

```java
public class LayoutsDemo extends Application {

    @Override
    public void start(Stage stage) {
        TilePane layout = new TilePane();

        Button[] buttons = new Button[12];

        for (int i = 0; i < 12; i++) {
            buttons[i] = new Button("" + (i + 1));
            layout.getChildren().add(buttons[i]);
        }

        Scene view = new Scene(layout);

        stage.setScene(view);
        stage.show();
    }
}
```


## 6.2.6. Nesting containers

## 6.2.7. Styling the UI with CSS


---
_This learning material has been produced with assistance from OpenAI's ChatGPT-4 and GitHub Copilot. These large language models have provided suggestions and solutions that have assisted the author in producing and supplementing the material. While their contribution has been significant, the final responsibility for the content and its correctness resides with the author._